{"version":3,"sources":["webpack:///./node_modules/markdown-it-katex/index.js"],"names":["katex","isValidDelim","state","pos","prevChar","nextChar","max","posMax","can_open","can_close","src","charCodeAt","math_inline","silent","start","match","token","pending","indexOf","push","markup","content","slice","math_block","end","firstLine","lastLine","next","lastPos","found","bMarks","tShift","eMarks","trim","blkIndent","lastIndexOf","line","block","getLines","map","module","exports","md","options","inline","ruler","after","alt","renderer","rules","tokens","idx","latex","displayMode","renderToString","error","throwOnError","console","log","katexInline","katexBlock"],"mappings":"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","file":"m-it-katex.js","sourcesContent":["/* Process inline math */\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = require('katex');\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n    var prevChar, nextChar,\n        max = state.posMax,\n        can_open = true,\n        can_close = true;\n\n    prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n    nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n    // Check non-whitespace conditions for opening and closing, and\n    // check that closing delimeter isn't followed by a number\n    if (prevChar === 0x20/* \" \" */ || prevChar === 0x09/* \\t */ ||\n            (nextChar >= 0x30/* \"0\" */ && nextChar <= 0x39/* \"9\" */)) {\n        can_close = false;\n    }\n    if (nextChar === 0x20/* \" \" */ || nextChar === 0x09/* \\t */) {\n        can_open = false;\n    }\n\n    return {\n        can_open: can_open,\n        can_close: can_close\n    };\n}\n\nfunction math_inline(state, silent) {\n    var start, match, token, res, pos, esc_count;\n\n    if (state.src[state.pos] !== \"$\") { return false; }\n\n    res = isValidDelim(state, state.pos);\n    if (!res.can_open) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos += 1;\n        return true;\n    }\n\n    // First check for and bypass all properly escaped delimieters\n    // This loop will assume that the first leading backtick can not\n    // be the first character in state.src, which is known since\n    // we have found an opening delimieter already.\n    start = state.pos + 1;\n    match = start;\n    while ( (match = state.src.indexOf(\"$\", match)) !== -1) {\n        // Found potential $, look for escapes, pos will point to\n        // first non escape when complete\n        pos = match - 1;\n        while (state.src[pos] === \"\\\\\") { pos -= 1; }\n\n        // Even number of escapes, potential closing delimiter found\n        if ( ((match - pos) % 2) == 1 ) { break; }\n        match += 1;\n    }\n\n    // No closing delimter found.  Consume $ and continue.\n    if (match === -1) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n        if (!silent) { state.pending += \"$$\"; }\n        state.pos = start + 1;\n        return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match);\n    if (!res.can_close) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    if (!silent) {\n        token         = state.push('math_inline', 'math', 0);\n        token.markup  = \"$\";\n        token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n    return true;\n}\n\nfunction math_block(state, start, end, silent){\n    var firstLine, lastLine, next, lastPos, found = false, token,\n        pos = state.bMarks[start] + state.tShift[start],\n        max = state.eMarks[start]\n\n    if(pos + 2 > max){ return false; }\n    if(state.src.slice(pos,pos+2)!=='$$'){ return false; }\n\n    pos += 2;\n    firstLine = state.src.slice(pos,max);\n\n    if(silent){ return true; }\n    if(firstLine.trim().slice(-2)==='$$'){\n        // Single line expression\n        firstLine = firstLine.trim().slice(0, -2);\n        found = true;\n    }\n\n    for(next = start; !found; ){\n\n        next++;\n\n        if(next >= end){ break; }\n\n        pos = state.bMarks[next]+state.tShift[next];\n        max = state.eMarks[next];\n\n        if(pos < max && state.tShift[next] < state.blkIndent){\n            // non-empty line with negative indent should stop the list:\n            break;\n        }\n\n        if(state.src.slice(pos,max).trim().slice(-2)==='$$'){\n            lastPos = state.src.slice(0,max).lastIndexOf('$$');\n            lastLine = state.src.slice(pos,lastPos);\n            found = true;\n        }\n\n    }\n\n    state.line = next + 1;\n\n    token = state.push('math_block', 'math', 0);\n    token.block = true;\n    token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '')\n    + state.getLines(start + 1, next, state.tShift[start], true)\n    + (lastLine && lastLine.trim() ? lastLine : '');\n    token.map = [ start, state.line ];\n    token.markup = '$$';\n    return true;\n}\n\nmodule.exports = function math_plugin(md, options) {\n    // Default options\n\n    options = options || {};\n\n    // set KaTeX as the renderer for markdown-it-simplemath\n    var katexInline = function(latex){\n        options.displayMode = false;\n        try{\n            return katex.renderToString(latex, options);\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    };\n\n    var inlineRenderer = function(tokens, idx){\n        return katexInline(tokens[idx].content);\n    };\n\n    var katexBlock = function(latex){\n        options.displayMode = true;\n        try{\n            return \"<p>\" + katex.renderToString(latex, options) + \"</p>\";\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    }\n\n    var blockRenderer = function(tokens, idx){\n        return  katexBlock(tokens[idx].content) + '\\n';\n    }\n\n    md.inline.ruler.after('escape', 'math_inline', math_inline);\n    md.block.ruler.after('blockquote', 'math_block', math_block, {\n        alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n    });\n    md.renderer.rules.math_inline = inlineRenderer;\n    md.renderer.rules.math_block = blockRenderer;\n};\n"],"sourceRoot":""}